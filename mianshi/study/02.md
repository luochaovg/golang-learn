### 复习 02
***

>缓存和数据库的基础知识

##### 1.描述一下redis有哪些数据结构。
- [redis知识点](http://www.cyc2018.xyz/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis.html)
- 基础的数据结构有5种，String/List/Hash/Set/Zset，还答了高级数据结构HyperLogLog/BitMap/BloomFilter/GeoHash。
BloomFilter的原理以及Zset的实现原理，主要讲解跳跃表。
- [BloomFilter原理](http://oserror.com/backend/bloomfilter/) 表示不懂
- [skipList跳跃表](https://segmentfault.com/a/1190000022320734)

##### 2.MySQL场景题目
- 面试官提供场景，要求写出查询SQL，考察联合语句，如何分页以及复杂语句的优化。

##### 3.树的非递归先序遍历
- [源代码](../algorithm/binary.go)
- ![图解](../algorithm/pic/WX20210306-113403@2x.png)
```go
// 先序遍历-非递归
func (bt *BinaryTree) PreOrderNoRecursion() []interface{} {
	t := bt
	stack := list.New()
	res := make([]interface{}, 0)
	for t != nil || stack.Len() != 0 {
		for t != nil {
			res = append(res, t.Data) //visit
			stack.PushBack(t)
			t = t.Left
		}
		if stack.Len() != 0 {
			v := stack.Back()
			t = v.Value.(*BinaryTree)
			t = t.Right
			stack.Remove(v)
		}
	}
	return res
}
```
##### 4.分布式事务以及分布式一致性等问题
- [分布式ID生成方案](https://tech.meituan.com/2017/04/21/mt-leaf.html)

##### 5.API业务的架构问题，负载均衡、CDN、DNS等问题

##### 6.HTTP的版本之间的区别，主要是1.0/1.1/2.0三个版本的区别。详细说了1.0与1.1之间是连接模型的区别(短连接、长连接、管线化)，1.1与2.0之间的区别是I/O多路复用的单一长连接、服务器推送、二进制分桢、首部压缩等。

##### 7.螺旋矩阵
- [力扣](https://leetcode-cn.com/problems/spiral-matrix/)
- [参考](https://github.com/olzhy/leetcode/blob/master/54_Spiral_Matrix/test.go)


#### 8.二叉树的最近公共祖先
- [参考](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/solution/golanger-cha-shu-de-gong-gong-zu-xian-by-wzycc/)
- [Demo](../algorithm/lowestcommancestor.go)
- ![图解](../algorithm/pic/WX20210306-174725@2x.png)
```go
type TreeNode struct {
  Val int
  Left *ListNode
  Right *ListNode
}

func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode { // 236. 二叉树的最近公共祖先
	if root == nil { // 此时不可能查询到结果
		return nil
	}
	if root.Val == p.Val || root.Val == q.Val { // 子树中寻找到结果节点，返回root
		return root
	}

	left := lowestCommonAncestor(root.Left, p, q)   // 寻找左子树
	right := lowestCommonAncestor(root.Right, p, q) // 寻找右子树

	if left == nil { // 从下一层返回来的查询结果为nil 没有找到
		return right
	} else if right == nil { // 从下一层返回来的查询结果为nil 没有找到
		return left
	} else { // 当左右子树都找到时返回root
		return root
	}

	return nil // 当在此棵子树上进行查找无pq时，返回nil
}

```


##### 9.大库DDL
- [参考](https://blog.csdn.net/frog4/article/details/82702745)
```text
mysql5.6 以后 online ddl
```

##### 10.一些算法(golang)
- [参考](https://www.liwenzhou.com/posts/Go/LeetCode/)

##### 11.GO垃圾回收
- [参考](https://juejin.cn/post/6844903917650722829)

#### 12.MySQL 到底是怎么解决幻读的？
- [参考](https://www.cnblogs.com/wudanyang/p/10655180.html)
- [参考](https://www.toutiao.com/i6930164998287589896/)
```text
一、什么是幻读
在一次事务里面，多次查询之后，结果集的个数不一致的情况叫做幻读。而多或者少的那一行被叫做 幻行

二、为什么要解决幻读
在高并发数据库系统中，需要保证事务与事务之间的隔离性，还有事务本身的一致性。

三、MySQL 是如何解决幻读的
如果你看到了这篇文章，那么我会默认你了解了 脏读 、不可重复读与可重复读。

1. 多版本并发控制（MVCC）（快照读/一致性读）
多数数据库都实现了多版本并发控制，并且都是靠保存数据快照来实现的。

以 InnoDB 为例。可以理解为每一行中都冗余了两个字段，一个是行的创建版本，一个是行的删除（过期）版本。
具体的版本号（trx_id）存在 information_schema.INNODB_TRX 表中。

版本号（trx_id）随着每次事务的开启自增。
事务每次取数据的时候都会取创建版本小于当前事务版本的数据，以及过期版本大于当前版本的数据。
普通的 select 就是快照读。
```

##### 13.mongoDb为什么使用B数
- [参考](https://www.jianshu.com/p/c068bd1fdaf7)
```text
MongoDB 认为查询单个数据记录远比遍历数据更加常见，由于 B 树的非叶结点也可以存储数据，所以查询一条数据所需要的平均随机 IO 次数会比 B+ 树少，
使用 B 树的 MongoDB 在类似场景中的查询速度就会比 MySQL 快.

```

##### 14.乐观锁，悲观锁
- [参考](https://www.jianshu.com/p/d2ac26ca6525)
```text
乐观锁比较适用于读多写少的情况(多读场景)，悲观锁比较适用于写多读少的情况(多写场景)。

悲观锁主要分为共享锁和排他锁：悲观锁：
共享锁【shared locks】又称为读锁，简称S锁。顾名思义，共享锁就是多个事务对于同一数据可以共享一把锁，都能访问到数据，但是只能读不能修改。
排他锁【exclusive locks】又称为写锁，简称X锁。顾名思义，排他锁就是不能与其他锁并存，如果一个事务获取了一个数据行的排他锁，其他事务就不能再获取该行的其他锁，包括共享锁和排他锁，但是获取排他锁的事务是可以对数据行读取和修改。

```