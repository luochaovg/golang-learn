```text
先记录下面试问的问题：

1、谈一下Go的GC机制 ， 说下三色标记算法的原理
(参考) https://zhuanlan.zhihu.com/p/297177002
(参考) https://github.com/luochaovg/golang/blob/main/5%E3%80%81Golang%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0+%E6%B7%B7%E5%90%88%E5%86%99%E5%B1%8F%E9%9A%9CGC%E6%A8%A1%E5%BC%8F%E5%85%A8%E5%88%86%E6%9E%90.md
Go V1.3之前的标记-清除(mark and sweep)算法 , 需要STW
标记-清扫(mark and sweep)的缺点
    STW，stop the world；让程序暂停，程序出现卡顿 (重要问题)。
    标记需要扫描整个heap
    清除数据会产生heap碎片

Go V1.5的三色并发标记法
白色 -> 灰色 -> 黑色 ， 回收所有的白色 ， 需要STW

“强-弱” 三色不变式
强三色不变式 : 不存在黑色对象引用到白色对象的指针。
弱三色不变式 : 所有被黑色对象引用的白色对象都处于灰色保护状态.
“插入屏障”: 满足: 强三色不变式 (STW 只扫描栈区间 ) 
“删除屏障”: 满足: 弱三色不变式 

插入写屏障和删除写屏障的短板：
插入写屏障：结束时需要STW来重新扫描栈，标记栈上引用的白色对象的存活；
删除写屏障：回收精度低，GC开始时STW扫描堆栈来记录初始快照，这个过程会保护开始时刻的所有存活对象。

Go V1.8的混合写屏障(hybrid write barrier)机制
混合写屏障规则
1、GC开始将栈上的对象全部扫描并标记为黑色(之后不再进行第二次重复扫描，无需STW)，
2、GC期间，任何在栈上创建的新对象，均为黑色。
3、被删除的对象标记为灰色。
4、被添加的对象标记为灰色。
满足: 变形的弱三色不变式.
 

以上便是Golang的GC全部的标记-清除逻辑及场景演示全过程。
GoV1.3-普通标记清除法，整体过程需要启动STW，效率极低。
GoV1.5-三色标记法，堆空间启动写屏障，栈空间不启动，全部扫描之后，需要重新扫描一次栈(需要STW)，效率普通
GoV1.8-三色标记法，混合写屏障机制， 栈空间不启动，堆空间启动。整个过程几乎不需要STW，效率较高。

3、算法：判断链表是否有回环
func HasRang(l *LinkList) bool {
	// 利用快慢指针
	slow := l
	fast := l

	for fast != nil && fast.Next != nil {
		slow = slow.Next
		fast = fast.Next.Next

		if fast == slow {
			return true
		}
	}

	return false
}

4、介绍下自己的项目

5、开发的流程规范是什么？

6、半连接是什么？

7、粘包是什么？怎么发送的？

8、怎么创建索引

9、怎么避免缓存击穿，还有其他的什么方法吗？

10、go的mutx怎么使用，乐观和悲观锁分别怎么实现，使用场景是什么？

11、服务器受到攻击怎么定位服务器问题？

12、rpc的具体实现

13、怎么反转树的左右节点

14、谈谈epoll和select

```